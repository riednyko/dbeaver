/*
 * Copyright (C) 2010-2014 Serge Rieder
 * serge@jkiss.org
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */
package org.jkiss.dbeaver.model.impl.data;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.jkiss.code.NotNull;
import org.jkiss.code.Nullable;
import org.jkiss.dbeaver.model.DBUtils;
import org.jkiss.dbeaver.model.data.DBDDataReceiver;
import org.jkiss.dbeaver.model.data.DBDValueHandler;
import org.jkiss.dbeaver.model.exec.*;
import org.jkiss.dbeaver.model.struct.DBSAttributeBase;
import org.jkiss.dbeaver.model.struct.DBSDataManipulator;
import org.jkiss.utils.ArrayUtils;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

/**
 * Execute batch.
 * Can be used in JDBC or any other underlying DB APIs
 *
*/
public class ExecuteBatchImpl implements DBSDataManipulator.ExecuteBatch {

    static final Log log = LogFactory.getLog(ExecuteBatchImpl.class);

    private DBCStatement statement;
    private final DBSAttributeBase[] attributes;
    private final List<Object[]> values = new ArrayList<Object[]>();
    private final DBDDataReceiver keysReceiver;
    private final boolean skipSequences;

    public ExecuteBatchImpl(@NotNull DBCStatement statement, @NotNull DBSAttributeBase[] attributes, @Nullable DBDDataReceiver keysReceiver, boolean skipSequences)
    {
        this.statement = statement;
        this.attributes = attributes;
        this.keysReceiver = keysReceiver;
        this.skipSequences = skipSequences;
    }

    @Override
    public void add(@NotNull Object[] attributeValues) throws DBCException
    {
        if (!ArrayUtils.isEmpty(attributes) && ArrayUtils.isEmpty(attributeValues)) {
            throw new DBCException("Bad attribute values: " + Arrays.toString(attributeValues));
        }
        values.add(attributeValues);
    }

    @NotNull
    @Override
    public DBCStatistics execute() throws DBCException
    {
        if (statement == null) {
            throw new DBCException("Execute batch closed");
        }
        DBDValueHandler[] handlers = new DBDValueHandler[attributes.length];
        for (int i = 0; i < attributes.length; i++) {
            handlers[i] = DBUtils.findValueHandler(statement.getSession(), attributes[i]);
        }

        boolean useBatch = statement.getSession().getDataSource().getInfo().supportsBatchUpdates();
        if (values.size() <= 1) {
            useBatch = false;
        }

        DBCStatistics statistics = new DBCStatistics();
        statistics.setQueryText(statement.getQueryString());
        for (Object[] rowValues : values) {
            int paramIndex = 0;
            for (int k = 0; k < handlers.length; k++) {
                DBDValueHandler handler = handlers[k];
                DBSAttributeBase attribute = attributes[k];
                if (skipSequences && (attribute.isPseudoAttribute() || attribute.isAutoGenerated())) {
                    continue;
                }
                handler.bindValueObject(statement.getSession(), statement, attribute, paramIndex++, rowValues[k]);
            }
            if (useBatch) {
                statement.addToBatch();
            } else {
                // Execute each row separately
                long startTime = System.currentTimeMillis();
                statement.executeStatement();
                statistics.addExecuteTime(System.currentTimeMillis() - startTime);

                long rowCount = statement.getUpdateRowCount();
                if (rowCount > 0) {
                    statistics.addRowsUpdated(rowCount);
                }

                // Read keys
                if (keysReceiver != null) {
                    readKeys(statement.getSession(), statement, keysReceiver);
                }
            }
        }
        values.clear();

        if (useBatch) {
            // Process batch
            long startTime = System.currentTimeMillis();
            int[] updatedRows = statement.executeStatementBatch();
            statistics.addExecuteTime(System.currentTimeMillis() - startTime);
            if (!ArrayUtils.isEmpty(updatedRows)) {
                for (int rows : updatedRows) {
                    statistics.addRowsUpdated(rows);
                }
            }
        }

        return statistics;
    }

    @Override
    public void close()
    {
        statement.close();
        statement = null;
    }

    private void readKeys(@NotNull DBCSession session, @NotNull DBCStatement dbStat, @NotNull DBDDataReceiver keysReceiver)
        throws DBCException
    {
        DBCResultSet dbResult;
        try {
            dbResult = dbStat.openGeneratedKeysResultSet();
        }
        catch (Throwable e) {
            log.debug("Error obtaining generated keys", e); //$NON-NLS-1$
            return;
        }
        if (dbResult == null) {
            return;
        }
        try {
            keysReceiver.fetchStart(session, dbResult);
            try {
                while (dbResult.nextRow()) {
                    keysReceiver.fetchRow(session, dbResult);
                }
            }
            finally {
                keysReceiver.fetchEnd(session);
            }
        }
        finally {
            dbResult.close();
            keysReceiver.close();
        }
    }
}
